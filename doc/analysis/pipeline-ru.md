# Инфраструктура для анализа физических событий StromaV

Классы анализа данных в StromaV предлагают набор базовых контрактов чьи
декларации исходят из следующих соображений:

1. Пользовательский код работает с набором экземпляров относительно небольшой
структуры данных — как минимум один экземпляр всегда умещается в памяти.
2. Таких структур предусмотрено, в общем, две: структура данных симулированного
события и структура данных экспериментального события. Для них предусмотрены
соответствующие поля в protobuf‐декларации класса Event.
3. В наиболее общем случае пользовательскому коду требуется последовательно
перебрать набор событий и произвести над каждым экземпляром одну и ту же
последовательность операций.

Первое положение представляет собой общее место большинства приложений
работающих с данными в ядерной физике и физике высоких энергий. Как правило,
одно событие умещается в памяти вычислительного узла.

Второе утверждение фиксируется с целью более связной интеграции с другими
частями StromaV, предоставляющими обобщённую функциональность для работы с
симулированными и реальными данными, — оба типа естественно присутствуют в
концепции библиотеки и обозначить интроспекцию делается целесообразно.

Третье положение является одной из двух довольно расхожих практикой при
анализе данных. Для экспериментальной статистики почти всегда нужно
предусмотреть преобразования данных события, которые могут быть обобщены
следующим образом:

Первый способ
предусматривает фиксированные типы данных на входах и выходах некоторых слоёв
абстракции разделённых по функциональному признаку (применение
калибровок, вычитание пьедесталов, аппроксимацию сигнала, и т.д.).
В такой концепции каждый последующий слой принимает и отдаёт различные
структуры данных и таким образом C++ гарантирует совместимость таких модулей —
если операция `A` принимает экземпляр «`RawEvent`» и возвращает экземпляр
«`EnergyDepostition_MeV`», а операция `B` принимает «`EnergyDepostition_MeV`»
и возвращает «`EnergySum_MeV`», то, очевидно, эти операции могут идти только в
определённом порядке.

Второй способ предусматривает унифицированную структуру данных для каждой
операции.

В `StromaV` мы применяем комбинированный подход, используя преимущества
интроспекции экземпляров `protobuf` — событие представлено унифицированным
типом данных позволяющим строго‐типизированные расширения посредством
композиции. Главным, и, по существу, единственным недостатком такого подхода
является необходимость изменения деклараций `protobuf` при добавлении новых
данных в структуру события. Важно заметить, что, однако, это не приводит к
серьёзному увеличению накладных расходов.

## Логика `sV::AnalysisPipeline`

Класс `sV::AnalysisPipeline` реализует расхожее решение подразумевающее
наличие итерируемого источника данных (data source) и упорядоченной цепочки
объектов‐обработчиков (handlers). В терминологии StromaV мы используем название
«event sequence» для источника событий чтобы подчеркнуть единственное
зафиксированное на данном уровне общности его свойство — однонаправленную
итерируемость. Для обработчиков (handlers) применяется название «processors»,
поскольку «handler» часто подразумевает реактивность экземпляра‐обработчика.

Организация классов приведена на диаграмме TODO. В общем, экземпляр
`AnalysisPipeline` реализует итерирование контрактора `_eventSequence` типа
`iEventSequence` и последовательно применение членов списка `_processorsChain`
типа `iEventProcessor` к извлечённому экземпляру события в методе `process()`,
чья диграмма активности приведена в иллюстрации TODO. Более подробно разделение
полномочий между источником данных, объектом `AnalysisPipeline` и цепочкой
процессоров показано на диаграмме TODO.

### Класс `sV::iEventSequence`

StromaV не предполагает за экземплярами событий более детальной топологии,
однако, поскольку всякий раз классы этих экземпляров предсавлены сообщениями
`protobuf`, возникает общая нужда кэширования десериализованных данных при
первом обращении с тем чтобы всякое последующее не вело к накладным расходам,
а так же инвалидации этого кэша при вычитке следующего события в
последовательности. Кроме того, при необходимоти сохранения обработанного
события, общей для пользовательского кода надобностью является сериализации
измененного кэша. Для этих целей предусмотрен шаблонный класс
`iEventPayloadProcessor`, а так же контейнеры коллбэков для вспомогательных
операций в `AnalysisPipeline`.

Примером класса‐контрактора `iEventSequence` может являться класс‐обёртка
сетевого сокета осуществляющего последовательное чтение приходящих в реальном
времени событий. Хотя в большинстве практических приложений плотность данных
обычно слишком высока чтобы производить над ними какие‐то ресурсоёмкие
операции, потребность считывания событий с потерями может возникнуть при
организации онлайн‐монитора событий, когда актуальность считываемых данных
важнее их целостности.

TODO: пример использования: выделенный в `iEventSequence` класс-потомок
`iMulticastEventReceiver`.

Нередко в практических приложениях возникает необходимость обеспечения
произвольного доступа к определённому событию. Если физический
источник данных (артефакт [TODO-footnote:
мы будем использовать термин «artefact» из UML 2.0 с тем чтобы избежать
неоднозначности связанной с определением «физический источник данных». Здесь
имеется в виду экземпляр на физическом носителе — файл, запись на стримере и
пр. ]) принципиально позволяет организацию такого
доступа (например являясь файлом на жёстком диске), StromaV предоставляет
набор обобщений на некотором прикладном уровне организующих интеграцию
метаданных и поисковой системой. Наиболее общий интерфейс такого источника
данных описан в шаблонном интерфейсе `iRandomAccessEventSource`. Более частная
специализация этого интерфейса должна подразумевать как минимум два общих
случая: в зависимости от того нуждается или нет артефакт источник данных в
дополнительной информации о своей внутренней структуре.

В том случае, если программный интерфейс может быть инкапсулирован одним
классом без значительных накладных расходов (напр. реализует запросы к БД) мы
предлагается использование класса `iBatchEventSource`.

В том же нередком случае когда метаданные велики, фрагментированны или не могут
быть приобретены за короткое время, на текущем архитектурном уровне может быть
целесообразно предоставить пользовательскому коду доступ к идентификатором
подресурса.

Например, в течение экспериментальной сессии статистика записывается в
несколько файлов у которых, кроме того, существует определённая внутрення
структура опредлённая режимом работы ускорителя подающего пучок в импульсном
режиме. Внутри каждого импульса событие может быть однозначно идентифицировано
порядковым номером. Таким образом, естественный идентификатор события состоял
бы из номера сессии, номера файла, номера импульса и, наконец, номера события.

Извлечь метаданные для накопленной статистики сразу и для всех сессий может
быть нецелесообразно по причине того что эксперимент не окончен (а значит нужно
предусмотреть возможность дополнения метаданных), определённые сеансы не
представляют интереса, и, наконец, объём статистики настолько велик, что
извлечение метаданных на одном узле неосуществимо. Для таких операций StromaV
вводит набор шаблонных интерфейсов: `iCachedMetadataType`,
реализующий логику запросов к интерфейсу `iMetadataStore` для идентификации
фрагментированных данных, доступ к которым предоставляется абстрактным
классом `iSectionalEventSource`. Более подробно работа с метаданными освещена
в [соответствующей главе](#TODO).

### Класс `iEventProcessor`

Хотя концепция «pipeline» предусматривает определённый произвол в определении
полномочий отдельных классов‐обработчиков, ведущим принципом при
построении таких классов является группировка на основе минимальной
функциональной идентичности (известный принцип системного программирования
UNIX «делать одно дело и делать его хорошо»). Наиболее общий контракт диктуемый
классом `AnalysisPipeline` выступающим здесь в роли диспетчера событий
закреплён абстрактным классом `iEventProcessor` и требует явной реализации
метадов `process_event()` принимающего указатель на экземпляр события имея
право модификации. В контракте так же определяются извещения об окончании
обработки события (метод `finalize_event()`) и о завершении последовательности
`finalize()`. Их введение обусловлено в большей степени инструментальным
удобством — как правило классы‐процессоры ассоциируются со внешними ресурсами,
которые следует оперативно освобождать для уменьшения накладных расходов
(закрытие файла, заполнение гистограмм, сериализация, и т.д.).

StromaV подразумевает разделение типов событий на экспериментальные и
модельные. Их идентификация опирается на механизм интроспекции protobuf и
архитектурной обязанностью данного уровня абстракции является предоставление
инструментального решения для дальнейшей идентификации в терминах StromaV,
которое реализованно в шаблонном классе `iEventPayloadProcessor`
параметризуемом типом загрузочных данных.



